% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/bootstrap.R
\name{boot_table}
\alias{boot_table}
\title{Bootstrap table.}
\usage{
boot_table(tab, n = 1, common_depth = FALSE, replace_zero = FALSE,
  round = FALSE)
}
\arguments{
\item{tab}{(Required). A matrix or data.frame of numeric counts/weights.}

\item{n}{(Optional). Default 1. An integer indicating the number of
boostrap count tables to return.}

\item{common_depth}{(Optional). Default \code{TRUE}. A logical or numeric
scalar. If numeric or \code{TRUE} the boostrap counts are normalized so
that the column sums are even and equal to \code{common_depth} or
\code{median} of the \code{tab} column sums respectively.}

\item{replace_zero}{(Optional). Default FALSE. A logical or numeric
scalar/vector replacing the zero probability of having a read for an OTU.
If numeric or TRUE zeros in \code{x} will be replaced
by \code{replace_zero} or 1 respectively, i.e. we add a small positive
weight in place of zeros. If \code{replace_zero} is a vector then each
component corresponds to respective columns of \code{tab}.}

\item{round}{(Optional). Default FALSE. A logical scalar. Should the
boostrap counts be rounded to the nearest integer?}
}
\value{
\code{n} x dim(\code{tab})[1] x dim(\code{tab})[2] 3D array of
samples boostrapped from \code{tab}.
}
\description{
\code{boot_table} returns samples boostrapped from table \code{tab}
supplied. Each column of the returned table is a boostrap trial of
the corresponding column of the \code{tab} input table.
If the supplied table, \code{T}, is a matrix of raw counts (integers),
the columns of the output table are multinomial samples with weights
proportional to corresponding columns of \code{tab}, otherwise the output
columns are samples from Dirichlet distribution with parameters equal
to corresponding columns of \code{tab}.
}
\examples{
x <- matrix(sample(1:1000, 30, replace = TRUE), 5, 6)
x[1, 4] <- 0; x[2, 5] <- 0; x[4, 6] <- 0; x[1, 5] <- 0
x
boot_table(x, n = 10)
boot_table(x, common_depth = 100)
boot_table(x, common_depth = 100, n = 10, round = TRUE)
boot_table(x, common_depth = 100, n = 10, replace_zero = 0.5)
}

